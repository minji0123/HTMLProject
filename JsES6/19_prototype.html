<script>
    //------------------------------------
    // Prototype
    //------------------------------------
    // Prototype 은 상속을 구현할 수 있는 문법이다.
    // 유전자
    // 엄마토끼의 성질을 그대로 물려받음

    function 엄마토끼(이름,키,무게){
        this.name = 이름;
        this.height = 20 + 키;
        this.weight = 10 + 무게;
        
    }
    
    var 아가토끼 = new 엄마토끼('버니',3,2);
    // 아기토끼.prototype
    
    // 생성자를 만들면 prototype 이라는 유전자가 자동으로 생긴다.
    // 님들 키가 큰 이유는 부모님이 물려주셨기 때문이다.
    // 마찬가지로 prototype 에 값을 추가하면 모든 자식들이 물려받을 수 있다.


    //------------------------------------
    // Prototype 특징(1)
    //------------------------------------
    // 1. 엄마토끼를 수정하면 자식토끼들까지 영향이감
    // 2. 엄마토끼에 뭔갈 추가하면 자식토끼들도 사용가능




    // 엄마토끼를 수정하면 자식토끼들까지 영향이감



    // 엄마토끼에 뭔갈 추가하면 자식토끼들도 사용가능
    function 엄마토끼(이름,키,무게){
        this.name = 이름;
        this.height = 20 + 키;
        this.weight = 10 + 무게;
        
    }
    // 엄마토끼한테 색 속성을 추가해줬다.
    엄마토끼.prototype.color = '핑크';

    var 아가토끼 = new 엄마토끼('버니',3,2);// 이제 아가토끼들은 다 핑크색이당
    // 아가토끼를 출력하면 color 가 나오진 않는다.
    // 하지만 아가토끼.color 는 할 수 있다.
    
    console.log(아가토끼.color);
    
    //------------------------------------
    // 동작순서(동작원리)
    // 오브젝트는 이런 순서로 자료를 출력한다.
    // 아가토끼의 key 값 먼저 확인하고, 없으면 상속해준 엄마토끼의 key 값을 확인해서 실행
    // 그래서 자식에게 값이 없으면 부모한테 물어본다.
    //------------------------------------




    //------------------------------------
    // 자바스크립트 내장 함수
    // Array.prototype, Object.prototype
    //------------------------------------
    아가토끼.toString();
    아가토끼.push();
    아가토끼.sort();
    // 아가토끼에도 없고 엄마토끼에도 없는 저 함수를 어떻게 쓰는거지?
    // 아가토끼의 key 값 먼저 확인하고, 없으면 상속해준 엄마토끼의 key 값을 확인해
    // 근에 엄마토끼에 없는데 왜 되냐
    // 엄마토끼의 엄마인 Object 에서 찾았기 때문이당


    //------------------------------------
    // 최고엄마
    //------------------------------------

    var arr = [1,2,3] // 배열 어케 만드냐면은
    var arr = new Array(1,2,3);// 실제로 이렇게 만들어진다.
    // 배열은 Array 라는 생성자로 배열 만들
    // 그래서 arr.map() 같은 걸 사용할 수 있는 것이다.
    // arr 에다가 sort, map 같은 함수를 만든 적이 없는데 사용할 수 있는 이유는
    // arr 의 부모 Array 가 sort 를 갖고있기 때문이다.

    // 그래서 배열은 typeof object 임
    // Array.prototype 출력해보면 sort 있음




    // object 도 마찬가지임
    {이름:'ㅁㄴㄹ'}// object 도 어케 만들어지냐면
    var obj = new Object({이름:'ㅁㄴㄹ'});// 이렇게 만들어진다.



    //------------------------------------
    // Prototype 특징(2)
    //------------------------------------
    // 3. prototype 은 생성자 함수에만 몰래 생성된다.
    // 일번 object, array 를 만들면 prototype 은 없음
    function 엄마토끼(이름,키,무게){
        this.name = 이름;
        this.height = 20 + 키;
        this.weight = 10 + 무게;
        
    }


    var 아가토끼 = new 엄마토끼('버니',3,2);
    // 아가토끼.prototype;// 이런거안됨
    엄마토끼.prototype;// 이건됨

    // 4. 그래서 아가를 통해 부모 생성자를 보고 싶다면 __proto__ 를 써야된다.
    아가토끼.__proto__



    // __proto__ 를 이용해서 부모님 강제로 등록하기
    var 엄마토끼 = {이름:'김'};
    var 아가토끼 = {};
    아가토끼.__proto__ = 엄마토끼;// 아가토끼를 만들어놓고 엄마토끼 지정해버리기





</script>


